extern crate proc_macro;


use syn::{parse_macro_input, DeriveInput, Error, Type};
use syn::{Field, Data, Fields, DataStruct, Generics};
use proc_macro2::{Ident, TokenStream};
use quote::{format_ident, quote_spanned, quote};
use syn::{Result, Token};
use syn::parse::{ParseStream};
use quote::ToTokens;

// Inspired by a part of SeaORM: https://github.com/SeaQL/sea-orm/blob/master/sea-orm-macros/src/derives/active_model.rs
// Assistance with macros provided by ChatGPT-4
#[proc_macro_derive(New, attributes(new))]
pub fn derive_new(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
    let DeriveInput { ident, data, generics, .. } = parse_macro_input!(input);

    derive_new_impl(ident, data, generics)
        .unwrap_or_else(Error::into_compile_error)
        .into()
}


pub(crate) fn derive_new_impl(ident: Ident,
                              data: Data,
                              generics: Generics) -> syn::Result<TokenStream> {
    let fields: Vec<_> = match &data {
        Data::Struct(DataStruct { fields, .. }) => match fields {
            Fields::Named(named) => named.named.clone(),
            Fields::Unit => Default::default(),
            _ => {
                return Ok(quote_spanned! {
                    ident.span() => compile_error!("you can only derive New on structs with named fields or empty structs");
                });
            }
        },
        _ => {
            return Ok(quote_spanned! {
                ident.span() => compile_error!("you can only derive New on structs");
            });
        }
    }.into_iter()
        .collect();

    let fields_with_types_and_settings: Vec<(TokenStream, Type, DefaultValue)> = fields.iter()
        .map(|field| {
            let ident = format_ident!("{}", field.ident.as_ref().unwrap());
            let name = quote!( #ident );
            let typed_name = {
                let field_type = field.ty.clone();
                field_type
            };
            let default_value = read_default_value(field)?;
            Ok((name, typed_name, default_value))
        })
        .collect::<syn::Result<Vec<_>>>()?;

    let defaults: Vec<_> = fields_with_types_and_settings.iter()
        .filter(|(_, _, value)| !matches!(value,  DefaultValue::None))
        .filter_map(|(filed_name, _, value)| {
            match value {
                DefaultValue::DefaultFunction(func) => {
                    Some(quote!(#filed_name: #func()))
                }
                DefaultValue::Default => {
                    Some(quote!(#filed_name: Default::default()))
                }
                _ => None
            }
        })
        .collect();


    let (constructor_field, field_with_types): (Vec<_>, Vec<_>) = fields_with_types_and_settings.into_iter()
        .filter_map(|(field, field_type, default_status)| {
            if let DefaultValue::None = default_status {
                let field_with_type = quote!( #field : #field_type );
                return Some((field, field_with_type));
            }
            None
        }).unzip();

    let defaults = {
        if defaults.is_empty() {
            quote!()
        } else if constructor_field.is_empty() {
            quote!(#(#defaults),*)
        } else {
            quote!(,#(#defaults),*)
        }
    };

    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();


    Ok(quote!(

        #[automatically_derived]
        impl #impl_generics  #ident #ty_generics #where_clause {
           pub fn new(#(#field_with_types),*) -> Self  {
                let result = Self {
                    #(#constructor_field),*
                    #defaults
                };
                result
            }

          

        }

    ))
}

#[derive(Debug)]
enum DefaultValue {
    None,
    Default,
    DefaultFunction(proc_macro2::TokenStream),
}

// generated by chat gpt
fn read_default_value(field: &Field) -> Result<DefaultValue> {
    let mut default_value: DefaultValue = DefaultValue::None;

    for attribute in &field.attrs {
        if attribute.path.is_ident("new") {
            if let DefaultValue::None = default_value {
                let component_args = attribute.parse_args_with(|input: ParseStream| {
                    if input.is_empty() {
                        return Err(input.error("Expected an argument after #[new(...)]."));
                    }

                    let _default_keyword: Token![default] = input.parse()?;

                    if input.peek(Token![=]) {
                        input.parse::<Token![=]>()?;

                        if input.peek(syn::Ident) {
                            let default_function: syn::Ident = input.parse()?;
                            Ok(DefaultValue::DefaultFunction(default_function.to_token_stream()))
                        } else {
                            Err(input.error("Expected a user-defined function identifier after #[new(default = ...)]."))
                        }
                    } else {
                        Ok(DefaultValue::Default)
                    }
                });

                match component_args {
                    Ok(value) => default_value = value,
                    Err(err) => return Err(err),
                }
            } else {
                return Err(syn::Error::new_spanned(
                    attribute,
                    "Multiple #[new(...)] annotations found. Ensure the field has only one #[new(...)] annotation.",
                ));
            }
        }
    }

    Ok(default_value)
}